## Stack 

### 1. Interface

| 接口      | 功能           |
| --------- | -------------- |
| `size()`  | 报告栈的规模   |
| `empty()` | 判断栈是否为空 |
| `push(e)` | 将e插至栈顶    |
| `pop()`   | 删除栈顶对象   |
| `top()`   | 引用栈顶对象   |

栈是一种简单的线性数据结构，最大的特点的是“先进后出”。`Stack`虽在实现上直接继承自`Vector`，但实际应用中通常只需将`vector`退化成一个数组，再增加相应接口即可。

### 2. Application

#### 2.1 栈与递归

递归调用的本事就是函数栈的堆叠。事实上，通过递归（特别是尾递归）的消除——转为迭代，能以有效地降低空间复杂度

#### 2.2 逆序输出

一些问题的输出为线性序列形式，同时需要逆序计算输出；且输入和输出的规模不确定，难以事先确定数据容器的大小。此时使用`stack`恰到好处。

示例 *进制转换*  

```sh
# ./Vector_Application/covert.cpp`
g++ -o convert convert.cpp
./convert
```

#### 2.3 递归嵌套

具有自相似性的问题可多嵌套地递归描述，但因分支位置和嵌套深度并不固定，其递归算法的复杂度不易控制。栈结构及其操作天然地具有递归嵌套性，故可用以高效地解决这类问题。

示例 1: *栈混洗*

可以证明含有n个元素的栈经过栈混洗之后，会有$catalan(n)=\frac{(2n)!}{(n+1)!·n!}$种情况

示例 2: *括号匹配*

```sh
# ./Vector_Application/paren.cpp
g++ -o paren paren.cpp
./paren`
```

#### 2.4 延迟缓冲

在一些应用中，输入可以分解成多个单元并通过迭代依次扫描处理，但过程中的各步计算往往滞后于扫描的进度，需要待到必要的信息已完整到一定程度之后，才能作出判断并实施计算。

示例: *表达式求值*

```pseudocode
compute
In: 表达式 expr
Out: 运算结果，原表达式的逆波兰表达式(rpn)
---------------------------------------------
引入栈opnd，用于存放操作数
引入栈optr，用于存放操作符
while (expr尚未扫描完毕)
	读取下一元素x
	if x is opnd
		opnd.push(x)
		append (RPN, opnd.top())
	else
		判断optr.top()与x的优先级
		if x 优先级更高
        	optr.push(x)	
        else 
        	op = optr.pop()
            从opnd中弹出需要的操作数
            cal(op, opnds)
            append (RPN, opnd.top())
    继续读取
返回栈顶(output), 返回RPN   	
```

```sh
# ./Vector_Application/computation.cpp
g++ -o computation computation.cpp
./computation
```

#### 2.5 BFS

借助栈实现广度优先算法

示例1：*八皇后问题*

```sh
# ./Vector_Application/queue.cpp
g++ -o queue queue.cpp
./queue N # N为皇后数量
```

> 输出样例

```c++
 0: [█][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ] 0
 1: [ ][ ][█][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ] 2
 2: [ ][ ][ ][ ][█][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ] 4
 3: [ ][█][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ] 1
 4: [ ][ ][ ][█][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ] 3
 5: [ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][█][ ][ ]17
 6: [ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][█][ ][ ][ ][ ][ ]14
 7: [ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][█][ ][ ][ ]16
 8: [ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][█]19
 9: [ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][█][ ][ ][ ][ ][ ][ ][ ]12
10: [ ][ ][ ][ ][ ][ ][ ][█][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ] 7
11: [ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][█][ ][ ][ ][ ]15
12: [ ][ ][ ][ ][ ][ ][█][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ] 6
13: [ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][█][ ]18
14: [ ][ ][ ][ ][ ][█][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ] 5
15: [ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][█][ ][ ][ ][ ][ ][ ][ ][ ][ ]10
16: [ ][ ][ ][ ][ ][ ][ ][ ][█][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ] 8
17: [ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][█][ ][ ][ ][ ][ ][ ]13
18: [ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][█][ ][ ][ ][ ][ ][ ][ ][ ]11
19: [ ][ ][ ][ ][ ][ ][ ][ ][ ][█][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ] 9
 solution::23 found after 7441479 check(s)
```

示例2: *迷宫问题*

```sh
# ./Vector_Application/laby.cpp
g++ -o laby laby.cpp
./laby 
```

> 输出样例

```c++
   0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L
 0 ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■
 1 ■         ■ ■             ■ ○ ○ ○ ○ ○ ○ ○ ■
 2 ■       ■     ■   $ ─ ─ ┐ ○ ○ ○ ○ ○ ■ ○ ○ ■
 3 ■       ■         ■ ■ ■ └ ─ ┐ ■ ○ ○ ■ ○ ○ ■
 4 ■ ■   ■     ■   ■       ■ ■ │ ○ ■ ○ ┌ ─ ┐ ■
 5 ■           ■       ■   ■ ■ │ ■   ┌ ┘ ■ │ ■
 6 ■   ■     ■ ■             ■ └ ─ ┐ │ ■ ┌ ┘ ■
 7 ■         ■         ■   ■ ■ ○ ■ │ │ ■ └ ┐ ■
 8 ■       ■ ┌ ─ ─ ─ ─ ─ ─ ─ ─ ┐ ■ └ ┘ ■ ┌ ┘ ■
 9 ■     ■ ○ └ ┐ ■ ■ ■ ■ ○ ○ ○ └ ─ ─ ┐ ■ └ ┐ ■
 A ■   ■ ■ ○ ■ └ ─ ─ ┐ ■ ○ ○ ○ ○ ○ ○ └ ─ ─ ┘ ■
 B ■ ■ ■ ■ ○ ○ ┌ ─ ─ ┘ ○ ■ ○ ○ ○ ○ ○ ○ ○ ■ ○ ■
 C ■ ○ ○ ○ ○ ■ └ ┐ ┌ ─ ┐ ■ ○ ○ ○ ○ ○ ■ ○ ■ ○ ■
 D ■ ○ ○ ○ ○ ○ ■ └ ┘ ■ │ ■ ○ ■ ○ ○ ○ ■ ○ ○ ○ ■
 E ■ ■ ○ ○ ○ ○ ○ ■ ○ ┌ ┘ ■ ○ ○ ■ ○ ○ ○ ○ ■ ○ ■
 F ■ ○ ○ ○ ○ ○ ■   ■ └ ┐ ○ ■ ○ ○ ○ ■ ■ ○ ○ ○ ■
 G ■ ○ ■ ○ ○ ■       ┌ ┘ ■ ┌ ─ ─ ─ ─ ─ ─ ─ ┐ ■
 H ■ ■ ■ ○ ■ ○ ■ ■ ┌ ┘ ■ ○ │ ■ ■ ■ ○ ■ ■ ■ │ ■
 I ■ ■ ○ ○ ■ ○ ○ ○ └ ┐ ○ ○ └ ┐ ○ ○ ■ ○ ○ ○ │ ■
 J ■ ○ ○ ■   ■ ■ ■ ■ └ ─ ┐ ○ │ ■ ■ ┌ ─ ─ ─ ┘ ■
 K ■ ○ ○ ○ ■ ■ ○ ○ ○ ○ ■ └ ─ ┘ ○ ■ └ ─ Ⓢ ■ ■ ■
 L ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■

Route found
```

> ■为障碍，$为终点，Ⓢ为起点，○为BFS途径过的点，—为通路路径

有障碍时，BFS解出的路径**往往不是**最短路径，更多有关路径搜索的讨论见  [Introduction-to-AI/Search/A-star](https://github.com/RichardS0268/Introduction-to-AI/tree/main/Search/A-star) 

## Queue

### 1. Interface

| 操作         | 功能                       |
| ------------ | -------------------------- |
| `size()`     | 报告队列的规模（元素总数） |
| `empty()`    | 判断队列是否为空           |
| `enqueue(e)` | 将e插入队尾                |
| `dequeue()`  | 删除队首队首对象           |
| `front()`    | 引用队首对象               |

Queue是一种简单的线性结构，最大的特点是先进先出。`Queue`可以基于`List`实现，也可以通过两个`Stack`实现。通过两个Stack实现时，通过三种不同的分析方法——Accounting, Aggregate, Potential进行均摊分析，可得这种实现方式仍满足单次操作$O(1)$的复杂度

### 2. Application

#### 2.1 任务调度

队列的结构适合为客户（client）群体中共享的某一资源进行分配。

示例：Bank Simulate

> 不同窗口，客户在随机时刻到达，办理业务所需时间随机，为期分配等待时间最短的窗口

```
# ./Queue_Application/bank_sim.cpp
g++ -o ban_sim bank_sim.cpp
./ban_sim 
```

#### 2.2 Queap

`Queap` 是`Queue`和`Heap`的结合，在原有接口上增加`getMax`或`getMin` 接口，可以在$O(1)$时间内得到最大/最小元素。Queap可以通过`Queue（List）`+`Heap`的方式实现，也可以通过两个`Steap`来实现

> 见 ./Queue_Application/Queap







